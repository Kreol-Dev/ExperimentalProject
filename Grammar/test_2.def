Определить действия
Определить генераторы
Определить события

Тестовый сценарий - стратегия про археологическую гонку. Нужны боты для членов экспедиций, управления экспедициями в целом, армий,
монстров и так далее.

Нужны генераторы лагерей, артефактов, монстров, людей и так далее.

Нужны события для лагерей, при исследовании артефактов и так далее.

Что происходит в условной игре.
Игрок является руководителем экспедиционной миссии. Есть карта, большая пустыня. 
Там тайно распологаются разного рода артефакты, подземные города, пещеры с ресурсами, гробницы и т.д.

У него есть конкуренты.

В задачу игрока входит формирование команд и установка археологических лагерей, 
охрана их, организация снабжения, полевых исследований, отправки артфактов на родину, 
реакция на случайные и не очень события.

Возможные вооружённые конфликты между игроками, однако если они выльются в войну на родине - 
вы проиграли. Вас арестовывают, а экспедицию сворачивают. А вот с монстрами, древними и прочими
придётся сражаться много.


Начнём с генераторов. Генерить нужно местность, объекты на ней в связной манере, сюжет, людей, страны, события. 

Предполагаем с самого начала, что, возможно, местность придётся дополнительно генерить в рантайме.
Для этого нужно будет определить граф с переменными окружения настраиваемыми через кастомный контекст (таблицу).
Затем создать генератор, который этот граф будет вызывать.
Создать генераторы, обрабатывающие элементы уже этого графа.

Поскольку генераторы - это действия, нужно подумать наконец о том, как от них всё же избавится в просчётах. 

В игре должно быть несколько типов лидеров. Это офицеры, учёные, администраторы.

По сути лидер - это объект с компонентами: Person, Entity и каким-либо набором из Officer, Scientist и Administrator. 

Археологический лагерь состоит из личностей, зданий, возглавляющего лидера и дополнительных компонентов, вроде гарнизона.

Из лагеря можно отправлять поисковые партии, а они в свою очередь могут формировать отдельные Раскопки на месте чего-то интересного.

Партии - набор личностей. Из личностей иногда получаются лидеры. Личности - что-то вроде героев в TDD.

Личности могут обладать дополнительными компонентами, трейтами. Например за личностью-офицером могут следовать дополнительные солдаты.
У личности-учёного могут быть ассистенты и так далее.


Существуют триггеры для ивентов. Например при прибытии каравана, при натыкании на что-то, или в течение путешествия.

По поводу ивентов можно решить что-то что потом поможет с кризисами. Аспекты событий и всё такое. Подумать!


Мы тут получаем ситуацию, когда базовые генераторы в основном идут по одному на интерфейс\компонент
По сути идея состоит в том, чтобы согласно scope и контексту определённым образом сгенерить компонент\интерфейс.
То есть при наличии одного и того же traits интерфейса но в разном контексте его стоит генерировать по-разному.
При этом становится вопрос в его добавлении как таковом. С одной стороны классы у меня определяются отдельно.
А с другой - добавляются динамически.
Судя по всему scope - будет аналогом live query у Parse, то есть реагировать на добавление любого объекта исходя из его генератора\слоя.
А слой как раз список объектов, которые можно даже сохранять и на которые можно ссылаться. ILayered как раз предоставляет этот функционал для объекта. 
Такие объекты можно создавать только через соответствующие слои.
Я полагаю, пока что, что слои общие на всех, и по одному на тип.

А что если идти через грамматики для генераторов\действий?

Так же встаёт вопрос о генерации не GameObject-ов. Похоже генерить нужно только gameobject-ы.
Тогда сразу решается проблема с объектами-компаньонами для проверки сгенерированности.
То есть я генерю gameobject-ы, после чего я так же как с action-ами могу запросить... я гений. Ведь так же как и действия я использую один механизм.
И таким образом можно делать перегрузки, имея одно и то же название для генератора иметь их несколько и выбирать то, которое наиболее подходит.

По поводу функций - их можно вызывать, но они не могут быть контентом таблицы напрямую, если не считать случая, когда это массив.

По идее в коде нужно будет определять как вызывать и откуда загружать списки. Либо через ресурсы.
Другой вопрос, что там нужно компилировать это дело, а значит до того загрузить моды, создать типы и всё такое.
Значит в коде мы скорее определяем какие типы нам нужны и когда и как мы их проверяем.


Судя по всему у нас есть следующие сущности в скриптах:
Scope - набор объектов отобранный по определённым критериям. Либо live, вынесенный в переменную scope и набор scopes, если предполагается live вообще.
Context - объект из scope к которому применяются операторы
Оператор - объект типа op_name = { ... } или op_name = ..., предполагает какое-то действие в отношении контекста
Custom Context - объект { ... } - таблица с параметрами, вместо представления объекта - формируется специально, либо просто отдельный объект
Функция - внешняя функция определённая для каких-то специфичных аргументов, может преобразовывать scope, объекты, применять выражения и так далее
в общем возвращает какие-то значения
Константа - контекстная переменная

Осталось разобраться с правилами. Базово конечно if - но там получаются то ли кастомные контексты, то ли непонятно что. Плюс в скоупах
не совсем ясно, как правильно представлять выражения для выборки.
Думаю что-то в духе:
do = {
	if = {
	
	}


}
Но возможно стоит ввести какой-то специальный конструкт для правил, хотя бы по той причине что так легче будет составлять условия.

Например:

:has_money = 100 and has_resource = { type = "metal" amount = 50 }:

Кроме того тут появляется нужда в операторах-функциях, вроде has_resource("metal") = 50, было бы удобно.
Но надо как-то это соотнести с уже существующими конструктами. Возможно это что-то вроде синтаксического сахара будет, а не реальным конструктом.
Типа - определяешь дефолтный порядок для оператора и он преобразует это в 
has_resource = { type = "metal" amount = 50}

rule: has_money = 100 and has_resource("metal") = 50

Вот так через операторы-функции и получается хорошо.
if(has_money = 100 and has_resource("metal") = 50) = { ... }

Операторы, константы, функции могут возвращать значения. Операторы, обычно, возвращают булеаны. 
Значения, тем не менее не обязательно принимать. 
map_gen = 
{
	scope = has_map
	action = 
	{
		set = 
		{
			name = 
		}
	}
}
culture_slot_gen =
{
	scope = has_landmass
	action = 
	{
		set = 
		{
			culture = 
			{
				traits = 
				{
					land_traits.{ somehow }
				}
			}
		}
	}
}
culture_gen = 
{
	scope = has_culture_slot.
	action = 
	{
		--Оператор
		set = 
		{
			--Имя интерфейса. Или добавляет его или меняет.
			culture = 
			{
				--Название параметра
				name = land_name + "ian"
				names_list = markov(resources.names.any_trait_from(culture.traits), 100)
				skin = resources.skin_colours.weight_by_traits(culture.traits).first
			}
		}
		
	}
}
country_gen = 
{
	scope = has_country_slot
	action = 
	{
		set =
		{
			cultures = 
			{
				cultures = country_lands.culture
				weights = country_lands.size.norm
			}
		}
	}
}
biome_gen = {}
mythos_gen = {}
expredition_gen = {}
tribe_gen = {}
leader_gen = {}
person_gen = {}
event_gen = 
{

}
location_gen = {}





