locations_filler =
{
	scope = space.fit(places = 0)
	utility = 1
	action = 
	{
		space = 
		{
			size = 5
			repeat(random(1,4)) = 
			{
				generate(loc) = 
				{
					entity = yes
					place = 
					{
						size = random(1, 3)
					}
					named = 
					{
						set("prefix", 0) = "Location of: "
						set("main_name", 1) = random_name(human_name)
					}
				}

				attach = loc.place
			}
		}
	}
}

named_ui = 
{
	scope = ui_object.markers.fit(showed_object.fit(has(named)) and not has_marker(named_ui_marker))
	utility = 1 
	action = 
	{
		markers.set_ui_marker = named_ui_marker
		ui_object = 
		{
			showed_named = showed_object.named
			create(text_field) = {
				show = showed_named.full_name
				showed_named.on_update = {
					show = showed_named.full_name
				}
				layout.min_height = 20
			}
		}
	}
}

place_ui = 
{
	scope = markers.ui_object.fit(showed_object.fit(has(place)) and not has_marker(place_ui_set))
	utility = 1
	action = 
	{
		markers.set_ui_marker = place_ui_set
		ui_object = 
		{
			pl = showed_object.place
			create(puidata) = place_ui_data
			puidata.last_size = pl.size
			create(text_field) = {
				show = pl.size
				if(not has(updated)) = 
				{
					create = updated
				}
				text_field.label = "size"
				layout.min_height = 20
				updated = {
					on_update.pl.puidata =
					{
						if(not (size = last_size)) = 
						{
							last_size = size
							show = size
						}
					}
				}
			}
		}
	}
}

agents_pool_filler = {
	scope = markers.place.fit(agents = 0 and has_marker(agents_pool))
	utility = 1
	action = {
		place = {
			size = 5
			repeat(random(1,4)) = {
				generate(ag) = {
					entity = yes
					agent = yes
					human = {
						age = random(20, 45)
					}
					named = {
						set("prefix", 0) = "Agent: "
						set("main_name", 1) = random_name(human_name)
					}
				}

				attach = ag.agent
			}
		}
	}
}

location_event = {
	scope = place.fit(not has(event_marker))
	utility = 1
	action = {
		create = event_marker
	}
}
agent_personality = {
	scope = agent.fit(not has(personality))
	utility = 1
	action = {
		create = personality
	}
}

aged_generation_add = {
	scope = human.fit(not has(aged_generation))
	utility = 1
	action = {
		create = aged_generation
	}
}

historical_persons = 
{
	scope = markers.lore.place.fit(agents = 0 and has_marker(lore_pool))
	utility = 1 
	action = 
	{
		place = {
			size = 10
			repeat(random(4,10)) = {
				generate(old_ag) = {
					entity = yes
					agent = yes
					historical_person = yes
					human = {
						age = random(30, 45)
					}
					named = {
						set("prefix", 0) = "Historical person: "
						set("main_name", 1) = random_name(human_name)
					}
				}

				attach = old_ag.agent
			}
		}
	}
}

change_name_historical_action = 
{
	scope = entity.historical_person.named.agent.fit(act = yes and not dead)
	utility = 0.5
	action = {
		named.switch("main_name") = random_name(human_name)
	}
}

location_log = 
{
	scope = place.named.fit(act = yes)
	utility = 0.3
	action  = 
	{
		log = named.get(main_name)
	}
}

destroy_self = 
{
	scope = entity.agent.fit(act = yes and not dead)
	utility = 0.01
	action = 
	{
		log = "Destroying self " + root
		destroy = root
	}
}


story_start = 
{
	scope = markers.fit(has_marker(init_node) and not has_marker(story_set)) 
	utility = 1
	action = 
	{

		markers.set_marker = story_set
		generate(s_node) =
		{
			tale_node = yes
			story_node = yes
			entity = yes
			markers = yes
		}
		s_node.tale_node.is_active = yes

	}
}

story_basic_decomposition = 
{
	scope = markers.story_node.tale_node.fit(not has_marker(decomposed) and is_active)
	utility = 1
	action = 
	{
		markers.set_marker = decomposed
		generate(c_node) = 
		{
			markers = yes
			tale_node = yes
			entity = yes
			conflict_node = yes
		}
		generate(c_r_node) = 
		{
			markers = yes
			tale_node = yes
			entity = yes
			conflict_resolution_node =
			{
				conflict = c_node
			}
		}
		generate(r_node) =
		{
			markers = yes
			tale_node = yes
			result_node = 
			{
				resolution = c_r_node
			}
		} 
		generate(s_node) =
		{
			markers = yes
			entity = yes
			tale_node = yes
			solution_node = 
			{
				cause = c_r_node
			}
		}
		generate(cris_node) =
		{
			entity = yes
			markers = yes
			tale_node = yes
			crisis_node = 
			{
				solution = s_node
				cause = r_node
			}
		}
		c_node.tale_node.is_active = yes
		c_r_node.tale_node.is_active = yes
		r_node.tale_node.is_active = yes
		s_node.tale_node.is_active = yes
		cris_node.tale_node.is_active = yes
		
	}
}

conflict_basic_decomposition = 
{
	scope = markers.conflict_node.tale_node.fit(not has_marker(decomposed) and is_active)
	utility = 1
	action = 
	{
		repeat(2) =
		{
			generate(f_node) =
			{
				tale_node = yes
				entity = yes
				faction_node = 
				{
					conflict = root
				}
				markers = yes
			}
			f_node.tale_node.is_active = yes
		}
		
		markers.set_marker = decomposed
	}
}

tale_ui_enlisting = 
{
	scope = markers.tale_node.fit(not has_marker(tale_enlisted))
	utility = 1
	action = 
	{
		generate(ui) =
		{
			ui_object =
			{
				showed_object = root
			}
			text_field =
			{
				layout.min_height = 20
				show = stringify(root)
			}
		}
		tales_ui_enlist = ui
		markers.set_ui_marker = tale_enlisted
	}
}


faction_is_a_state = 
{
	scope = faction_node.markers.fit(not has_marker(faction_is_a_state))
	utility = 1
	action = 
	{
		create = state_node
		markers.set_marker = faction_is_a_state
	}
}

state_name = 
{
	scope = state_node.fit(not has(named))
	utility = 1
	action = 
	{
		create(named) = 
		{
			set("main_name", 0) = random_name(country_name)
		}
	}
}

state_head = 
{
	scope = state_node.tale_node.fit(not has(head) and is_active)
	utility = 1
	action = 
	{
		state_node = 
		{
			generate(head_of_state) = 
			{	
				markers = yes
				person_node = yes
				tale_node = yes
				head_of_state_node = 
				{
					state = root
				}
				entity = yes
			}
			head_of_state.tale_node.is_active = yes
			head = head_of_state
		}
	}
}

state_head_death = 
{
	scope = event.markers.entity_death_event.fit(context.fit(has(head_of_state_node)) and not has_marker(state_head_death_reacted))
	utility = 1
	action = 
	{
		markers.set_marker = state_head_death_reacted
		event.context.head_of_state_node.state.state_node.head = no_one
	}
}
state_head_name = 
{
	scope = head_of_state_node.fit(not has(named))
	utility = 1
	action = {
		create(named) =
		{
			set(main_name, 0) = random_name(human_name)
		}
	}
}